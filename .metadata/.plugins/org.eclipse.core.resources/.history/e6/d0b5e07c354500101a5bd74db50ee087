/* USER CODE BEGIN Includes */
#include <math.h>
/* USER CODE END Includes */

/* USER CODE BEGIN PV */
float pos_target_L = 0, pos_target_R = 0;
float vel_integral_L = 0, vel_integral_R = 0;
int32_t prev_ticks_L = 0, prev_ticks_R = 0;
/* USER CODE END PV */

/* USER CODE BEGIN PFP */
float read_position_L(void);
float read_position_R(void);
float read_velocity_L(void);
float read_velocity_R(void);
float cascaded_control(float pos_target, float pos_current, float vel_current, float *vel_integral);
void set_motor_pwm_L(float pwm);
void set_motor_pwm_R(float pwm);
/* USER CODE END PFP */

/* USER CODE BEGIN 2 */
// Example gain values, tune as needed
float kpp = 10.0f;  // Position P gain
float kvp = 5.0f;   // Velocity P gain
float kvi = 1.0f;   // Velocity I gain
float kenc = 1.0f;  // encoder ticks to distance
/* USER CODE END 2 */

/* USER CODE BEGIN 3 */
while (1)
{
    float pos_current_L = read_position_L();
    float pos_current_R = read_position_R();
    float vel_current_L = read_velocity_L();
    float vel_current_R = read_velocity_R();

    float pwm_L = cascaded_control(pos_target_L, pos_current_L, vel_current_L, &vel_integral_L);
    float pwm_R = cascaded_control(pos_target_R, pos_current_R, vel_current_R, &vel_integral_R);

    set_motor_pwm_L(pwm_L);
    set_motor_pwm_R(pwm_R);

    HAL_Delay(10);
}
/* USER CODE END 3 */

/* USER CODE BEGIN 4 */
float cascaded_control(float pos_target, float pos_current, float vel_current, float *vel_integral)
{
    float vel_ref = kpp * (pos_target - pos_current);
    float vel_error = vel_ref - vel_current;
    *vel_integral += vel_error * 0.01f;

    float pwm = kvp * vel_error + kvi * (*vel_integral);

    if (pwm > 100.0f) {
        pwm = 100.0f;
        *vel_integral -= vel_error * 0.01f;
    } else if (pwm < -100.0f) {
        pwm = -100.0f;
        *vel_integral -= vel_error * 0.01f;
    }

    return pwm;
}

float read_position_L(void)
{
    return encoder_ticks_L * kenc;
}

float read_position_R(void)
{
    return encoder_ticks_R * kenc;
}

float read_velocity_L(void)
{
    int32_t delta = encoder_ticks_L - prev_ticks_L;
    prev_ticks_L = encoder_ticks_L;
    return delta * kenc / 0.01f;
}

float read_velocity_R(void)
{
    int32_t delta = encoder_ticks_R - prev_ticks_R;
    prev_ticks_R = encoder_ticks_R;
    return delta * kenc / 0.01f;
}

void set_motor_pwm_L(float pwm)
{
    if (pwm >= 0) {
        HAL_GPIO_WritePin(DIR_L_GPIO_Port, DIR_L_Pin, GPIO_PIN_SET);
    } else {
        HAL_GPIO_WritePin(DIR_L_GPIO_Port, DIR_L_Pin, GPIO_PIN_RESET);
        pwm = -pwm;
    }
    __HAL_TIM_SET_COMPARE(&htim_L, TIM_CHANNEL_1, (uint16_t)pwm);
}

void set_motor_pwm_R(float pwm)
{
    if (pwm >= 0) {
        HAL_GPIO_WritePin(DIR_R_GPIO_Port, DIR_R_Pin, GPIO_PIN_SET);
    } else {
        HAL_GPIO_WritePin(DIR_R_GPIO_Port, DIR_R_Pin, GPIO_PIN_RESET);
        pwm = -pwm;
    }
    __HAL_TIM_SET_COMPARE(&htim_R, TIM_CHANNEL_1, (uint16_t)pwm);
}
/* USER CODE END 4 */
